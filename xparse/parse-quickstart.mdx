---
title: "快速启动"
---

### 先决条件：获取API Key

使用文档解析API处理文档时，您需要先获取API Key。请先登录后前往 [TextIn工作台 - 账号与开发者信息](https://www.textin.com/console/dashboard/setting) 获取您的API Key。

### 前置准备

```python
import json
import requests

class OCRClient:
    def __init__(self, app_id: str, secret_code: str):
        self.app_id = app_id
        self.secret_code = secret_code

    def recognize(self, file_content: bytes, options: dict) -> str:
        # 构建请求参数
        params = {}
        for key, value in options.items():
            params[key] = str(value)

        # 设置请求头
        headers = {
            "x-ti-app-id": self.app_id,
            "x-ti-secret-code": self.secret_code,
            # 方式一：读取本地文件
            "Content-Type": "application/octet-stream"
            # 方式二：使用URL方式
            # "Content-Type": "text/plain"
        }

        # 发送请求
        response = requests.post(
            f"https://api.textin.com/ai/service/v1/pdf_to_markdown",
            params=params,
            headers=headers,
            data=file_content
        )

        # 检查响应状态
        response.raise_for_status()
        return response.text

def main():
    # 创建客户端实例
    client = OCRClient("你的x-ti-app-id", "你的x-ti-secret-code")

	# 插入下面的示例代码

if __name__ == "__main__":
    main()
```

### 解析单个本地文件并保存结果

当您使用文档解析API想要解析单个本地文件时，您可以参考以下示例代码。

复制以下代码，粘贴至前置准备代码的main函数中。

```python
    # 在main函数中插入
    # 读取本地文件
    with open("你的文件.pdf", "rb") as f:
        file_content = f.read()

    # 设置URL参数，可按需设置，这里已为你默认设置了一些参数
    options = dict(
        dpi=144,
        get_image="objects",
        markdown_details=1,
        page_count=10,
        parse_mode="auto",
        table_flavor="html",
    )

    try:
        response = client.recognize(file_content, options)

        # 保存完整的JSON响应到result.json文件
        with open("result.json", "w", encoding="utf-8") as f:
            f.write(response)

        # 解析JSON响应以提取markdown内容
        json_response = json.loads(response)
        if "result" in json_response and "markdown" in json_response["result"]:
            markdown_content = json_response["result"]["markdown"]
            with open("result.md", "w", encoding="utf-8") as f:
                f.write(markdown_content)

        print(response)
    except Exception as e:
        print(f"Error: {e}")
```

### 解析多个本地文件并保存结果至指定目录下

当您使用文档解析API想要解析多个本地文件时，您可以参考以下示例代码。

复制以下代码，粘贴至前置准备代码的main函数中。

```python
 	# 在main函数中插入
    # 读取本地文件夹
    input_dir = "./tmp"  # 你可以修改为自己的文件夹
    output_dir = "./output"  # 输出结果的文件夹
	import os
    os.makedirs(output_dir, exist_ok=True)

    # 支持的文件类型
    exts = (".pdf",".png",".jpg",".jpeg",".bmp",".tiff",".webp",".doc",".docx",".html",".mhtml",".xls",".xlsx",".csv",".ppt",".pptx",".txt")
    files = [f for f in os.listdir(input_dir) if f.lower().endswith(exts)]

    # 设置URL参数，可按需设置，这里已为你默认设置了一些参数
    options = dict(
        dpi=144,
        get_image="objects",
        markdown_details=1,
        page_count=10,
        parse_mode="auto",
        table_flavor="html",
    )

    #循环处理
    for filename in files:
        file_path = os.path.join(input_dir, filename)
        with open(file_path, "rb") as f:
            file_content = f.read()
        try:
            response = client.recognize(file_content, options)
            base_name = os.path.splitext(filename)[0]
            # 保存JSON
            with open(os.path.join(output_dir, f"{base_name}.json"), "w", encoding="utf-8") as fw:
                fw.write(response)
            # 保存Markdown
            json_response = json.loads(response)
            if "result" in json_response and "markdown" in json_response["result"]:
                markdown_content = json_response["result"]["markdown"]
                with open(os.path.join(output_dir, f"{base_name}.md"), "w", encoding="utf-8") as fw:
                    fw.write(markdown_content)
            print(f"{filename} 处理完成")
        except Exception as e:
            print(f"{filename} 处理出错: {e}")
```

### 解析位于URL的文件并保存结果

当您使用文档解析API想要解析位于URL的文件时，您可以参考以下示例代码。

- 修改请求头设置。

```python
        # 在前置准备中设置请求头
        headers = {
            "x-ti-app-id": self.app_id,
            "x-ti-secret-code": self.secret_code,
            # 方式二：使用URL方式
            "Content-Type": "text/plain"
        }
```

- 复制以下代码粘贴至前置准备代码的main函数中。

```python
    # 在main函数中插入
    # 使用URL方式，这里为你提供了一份真实可用的示例URL
    file_content = "https://dllf.intsig.net/download/2025/Solution/textin/sample/pdf_to_markdown/sample_02.pdf"

    # 设置URL参数，可按需设置，这里已为你默认设置了一些参数
    options = dict(
        dpi=144,
        get_image="objects",
        markdown_details=1,
        page_count=10,
        parse_mode="auto",
        table_flavor="html",
    )

    try:
        response = client.recognize(file_content, options)

        # 保存完整的JSON响应到result.json文件
        with open("result.json", "w", encoding="utf-8") as f:
            f.write(response)

        # 解析JSON响应以提取markdown内容
        json_response = json.loads(response)
        if "result" in json_response and "markdown" in json_response["result"]:
            markdown_content = json_response["result"]["markdown"]
            with open("result.md", "w", encoding="utf-8") as f:
                f.write(markdown_content)

        print(response)
    except Exception as e:
        print(f"Error: {e}")
```

### URL参数说明

以下是文档解析API的URL参数，参数会影响文档的解析结果和JSON输出内容，您可按需进行设置。

- **pdf_pwd**：当pdf为加密文档时，需要提供密码。
  - 备注：对前端封装该接口时，需要自行对密码进行安全防护。
- **char_details**：当为1或true时，可以返回char_pos字段，保存每一行的位置信息。默认关闭。
- **page_details**：当为1或true时，可以返回pages字段，保存每一页更加详细的解析结果。默认打开。
- **catalog_details**：当为1或true时，可以返回catalog details。
- **dpi**：pdf文档的坐标基准，默认144 dpi。 与parse_mode参数联动
  - 当parse_mode=auto时，默认动态，支持72，144，216； 
  - 当parse_mode=scan时，默认144，支持72，144，216。
- **page_start**：当上传的是pdf时，表示从第几页开始转。
- **page_count**：当上传的是pdf时，表示要进行转换的pdf页数。总页数不得超过1000页，默认为1000页。
- **apply_document_tree**：是否生成标题，默认为1，生成标题。
  - 0 不生成
  - 1 生成标题
- **markdown_details**：是否生成markdown details，默认为1，生成markdown details。
  - 0 不生成
  - 1 生成
- **table_flavor**：markdown里的表格格式，默认为html，按html语法输出表格。
  - md 按md语法输出表格
  - html 按html语法输出表格
  - none 不进行表格识别，把表格图像当成普通文字段落来识别。
- **get_image**：获取markdown里的图片，默认为none，不返回任何图像。
  - none 不返回任何图像
  - page 返回每一页的整页图像
  - objects 返回页面内的图像对象
  - both 返回整页图像和图像对象
- **image_output_type**：指定引擎返回的图片对象输出类型，默认返回子图片url和页图片id。
  - base64str 指定所有图片对象为base64字符串，适用于没有云存储的用户，但是引擎返回结果体积会很大。
  - default 指定子图片对象为图片url，页图片对象为图片id
- **parse_mode**：PDF解析模式，默认为scan模式，仅按文字识别方式处理。图片不用设置，均按文字识别方式处理。
  - auto 综合文字识别和解析模式
  - scan 仅按文字识别模式
- **get_excel**：是否返回excel结果，结果字段为excel_base64，默认为0，不返回。
  - 0 不返回
  - 1 返回
- **raw_ocr**：是否返回全文识别结果，结果字段为raw_ocr。默认为0，不返回。与page_details参数联动，当page_details为0或false时不返回。
  - 0 不返回
  - 1 返回
- **切边矫正**（需联系商务获取参数名）：是否进行切边矫正处理，默认为0，不进行切边矫正。
  - 0 不进行切边矫正
  - 1 进行切边矫正
- **去水印**（需联系商务获取参数名）：是否进行去水印处理，默认为0，不去水印。
  - 0 不去水印
  - 1 去水印
- **图表识别**（需联系商务获取参数名）：是否开启图表识别，开启图表识别会将识别到的图表以表格形式输出。默认为0，不进行图表识别。
  - 0 不开启图表识别
  - 1 开启图表识别
- **paratext_mode**：markdown中非正文文本内容展示模式。默认为annotation。非正文内容包括页眉页脚，子图中的文本。
  - none 不展示
  - annotation 以注释格式插入到markdown中。页眉页脚中的图片只保留文本，图片base64或url不保留
  - body 以正文格式插入到markdown中
- **formula_level**：公式识别等级，默认为0，全识别。
  - 0 全识别
  - 1 仅识别行间公式，行内公式不识别
  - 2 不识别
- **apply_merge**：是否进行段落合并和表格合并。默认为1，合并段落和表格。
  - 0 不合并
  - 1 合并

### 返回结果示例

当您使用文档解析API时，解析后的结果数据将按照以下JSON格式返回，下面为您提供了一段返回示例。如果您想了解最全面的返回结果，可以在[API文档](/api-reference/endpoint/parse)中查看。

<Tip>
  示例文件URL：https://dllf.intsig.net/download/2025/Solution/textin/sample/pdf_to_markdown/sample_02.pdf
</Tip>

```json expandable
```