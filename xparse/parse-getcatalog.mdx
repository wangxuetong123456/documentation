---
title: "获取目录树"
---

在处理长篇技术文档、学术论文或企业规范文档时，RAG系统面临的最大挑战之一是如何理解内容的逻辑层次和上下文关系。简单的文本分块往往会破坏文档的原有结构，导致检索到的信息缺乏必要的背景context。例如：当用户询问"数据安全相关的实施要求"时，如果系统无法区分这些要求是来自"总体概述"、"技术规范"还是"合规检查"章节，就可能提供不准确或不完整的信息。

实践中通常有一种技巧，即利用文档的标题层级分chunk，然后在检索和重排序的时候也利用标题层级过滤无关的chunk，从而提升Top5召回的相关度，以便让大模型在最终回答时效果更好。

在TextIn xParse文档解析API中，我们提供了获取文档标题层级的功能，最多可支持6级标题的输出，您可以基于API的返回结果来构建完整的文档目录树。

## 如何获取目录树

当您想要获取文档目录树(即大纲结构)时，您可以参考以下教程和示例代码。

- 参考[快速启动](/xparse/parse-quickstart)，在 options 中设置URL参数 catalog_details=1，API会在返回结果中包含目录相关信息。
- 在main函数中添加以下示例代码，获取API输出的目录信息，并保存为 json 文件。

```python
if "result" in json_response and "catalog" in json_response["result"]:
    catalog = json_response["result"]["catalog"]
    
    # 保存为json文件
    import json
    with open("catalog.json", "w", encoding="utf-8") as f:
        json.dump(catalog, f, ensure_ascii=False, indent=2)
    print("目录已保存为 catalog.json")
else:
    print("未检测到目录字段，可能文档没有目录或参数设置有误。")
```

- 请注意：为了更加灵活的支持下游业务场景，文档解析API的目录返回结果中通过**hierarchy**字段表示目录的标题层级，并没有目录之间直接的父子层级关系，您可以参考以下示例代码获取标题目录间的父子层级关系，以构建目录树状结构。

```python
    toc_list = data['catalog']['toc']
    result = []
    parent_stack = []  # 用于跟踪当前路径上的父节点
    
    for item in toc_list:
        # 复制当前项目，避免修改原始数据
        current_item = item.copy()
        current_item['children'] = []
        
        current_level = item.get('hierarchy', 1)
        
        # 根据层级调整父节点栈
        # 移除层级大于等于当前层级的节点
        while parent_stack and parent_stack[-1]['hierarchy'] >= current_level:
            parent_stack.pop()
        
        # 如果有父节点，将当前项目添加到父节点的children中
        if parent_stack:
            parent_stack[-1]['children'].append(current_item)
        else:
            # 如果没有父节点，说明是根节点
            result.append(current_item)
        
        # 将当前项目添加到父节点栈中
        parent_stack.append(current_item)
    
    return result
```